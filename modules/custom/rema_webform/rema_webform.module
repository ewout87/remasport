<?php

use Drupal\Component\Serialization\Yaml;
use Drupal\node\NodeInterface;
use Drupal\webform\Entity\Webform;
use Drupal\node\Entity\Node;

/**
 * @file
 * Primary module hooks for Webform Summation Field module.
 */



/**
 * Implements hook_webform_submission_presave().
 */
function mymodule_webform_submission_presave(WebformSubmission $webform_submission) {
  $total_sum_field_key = '';
  $webform = $webform_submission->getWebform();
  $webform_fields = $webform->getElementsDecoded();

  foreach ($webform_fields as $key => $value) {
    if (isset($value['#type']) && $value['#type'] == 'total_sum') {
      $total_sum_field_key = $key;
      break;
    }
  }

  if ($total_sum_field_key) {
    $data = $webform_submission->getData();
    $result = 0;
    foreach ($data as $key => $value) {
      if (isset($value['#type']) && $value['#type'] == 'computed_field') {
        $result += $value;
      }
    }
    $data[$total_sum_field_key] = $result;
    $webform_submission->setData($data);
    $webform_submission->setElementData($total_sum_field_key, $result);
    $webform->invokeHandlers('overrideSettings', $webform_submission);
  }
}

/**
 * Implements hook_webform_submit().
 */
function mymodule_webform_submit(WebformSubmission $webform_submission) {
	// Define a payment object.
	$payment = new Payment();
	$payment->context = 'donation';
	$payment->context_data = array(
	  'time' => time(),
	  'type' => 'donation',
	);
	$payment->currency_code = 'EUR';
	$payment->description = 'Basic payment form';
	$payment->finish_callback = 'MYMODULE_finish_callback';

	// Define a payment line item.
	$line_item = new PaymentLineItem();
	$line_item->amount = 100.00 / 1.21;
	$line_item->name = t('EUR 100');
	$line_item->tax_rate = 0.21;
	$line_item->quantity = 1;

	// Add the payment line item to the payment object.
	$payment->setLineItem($line_item);

	// Add the payment object to the form.
	$form_state['payment'] = $payment;

	// Get available payment methods and limit this form to Mollie payment.
	$payment_methods = $payment->availablePaymentMethods();
	$payment_options = array();
	foreach ($payment_methods as $payment_method) {
	  if ($payment_method->enabled && $payment_method->name == 'pay_with_mollie') {
	    $payment_options[] = $payment_method->pmid;
	  }
	}

	// Get the payment embed elements.
	$payment_embed_form = payment_form_embedded($form_state, $payment, $payment_options);

	// Add the embedded payment form element.
	$form['payment'] = $payment_embed_form['elements'];

	// Define the form submit callback.
	$form['#submit'] = $payment_embed_form['submit'];
}


/**
* Handle successful payment from Mollie.
*
* @param \Payment $payment
*   The returned payment object containing all relevant information.
*/
function MYMODULE_finish_callback(Payment $payment) {
  $payment_complete = FALSE;

  // Check if the payment status contains a successful state.
  foreach ($payment->statuses as $status) {
    if ($status->status == 'payment_status_success') {
      $payment_complete = FALSE;
      break;
    }
  }

  if ($payment_complete) {
    drupal_set_message('Your payment has been received.', 'success');
    // @TODO: Implement custom callbacks.
  }
}




/**
 * Implements hook_ENTITY_TYPE_presave() for node entities.
 */
function rema_webform_node_presave(NodeInterface $node)
{
  if ($node->bundle() == 'webform') {
    $webform = $node->get('webform')->getValue();

   

    if (empty($webform)) {
      $bundles = $node->get('field_webform_bundles')->getValue();

      // Build a render array of elements.
      $elements= [];
      
      $settings = [
        // Define settings.
      ];

      if (!empty($bundles)) {

        $elements['selection'] = [
          '#type' => 'webform_wizard_page',
          '#title' => 'Selectie',
          'bundle_select' => [
            '#type' => 'radios',
            '#title' => 'Pakketten',
            '#options' => [],
            '#options_display' => 'buttons',
            '#required' => true,
            '#states_clear' => false,
            '#options__properties' => ''
          ]
        ];

        foreach ($bundles as $key => $value) {
          $bundle_id = $value['target_id'];

          $bundle = Node::load($bundle_id);

          if ($bundle instanceof NodeInterface) {
            $bundle_title = $bundle->getTitle();
            $bundle_id = $bundle->id();

            $elements['selection']['bundle_select']['#options'][] = $bundle_title;

            $elements['bundle_'.$bundle_id] = [
              '#type' => 'webform_wizard_page',
              '#title' => $bundle_title,
              '#states' => [
                visible => [
                  ':input[name="bundle_select"]' => [
                    value => $key
                    ]
                  ]
                ]
            ];

            $products = $bundle->get('field_bundle_products')->getValue();
            if (!empty($products)) {
              foreach ($products as $product) {
                $product_id = $product['target_id'];

                $product = Node::load($product_id);

                if ($product instanceof NodeInterface) {
                  $product_title = $product->getTitle();
                  $sizes = $product->get('field_product_size_range')->getValue();

                  if (!empty($sizes)) {
                  $size_range = get_size_options($sizes);

                  $product_id = $product->id();
                  $webform_key = 'bundle_'.$bundle_id.'_product_'.$product_id;

                  $elements['bundle_'.$bundle_id][$webform_key] = [
                      '#type' => 'webform_flexbox',
                      $webform_key.'_size' => [
                        '#type' => 'select',
                        '#title' => 'Maat',
                        '#options' => $size_range,
                        '#required' => true
                      ],
                      $webform_key.'_amount' => [
                        '#type'=> 'number',
                        '#title' => 'Aantal',
                        '#min' => 1,
                        '#default_value' => 1
                      ],
                      $webform_key.'_calculation' => [
                        '#type' => 'webform_computed_twig',
                        '#title' => 'Berekening',
                        '#template' => '
                          {% if data.' . $webform_key . '_size %}
                          {% set total= data.' . $webform_key . '_size*data.'. $webform_key .'_amount %}
                          {% endif %}
                          {{total}}',
                        '#ajax' => true
                      ]
                    ];
                  }
                }
              }
            }
          }
        }

        $elements['extra'] = [
          '#type' => 'webform_wizard_page',
          '#title' => 'Vrije keuze',
        ];

        foreach($elements as $wizard_page){
          array_push($elements['extra'], array_values($wizard_page))
        }
      }


      // Append default settings.
      $settings += Webform::getDefaultSettings();

      // Create a webform.
      $webform = Webform::create([
        'id' => 'webform_' . $node->id(),
        'title' => $node->getTitle(),
        'elements' => Yaml::encode($elements),
        'settings' => $settings,
      ]);

      $webform->save();

      $node->set('webform', $webform->id());
    }
  }
}

/**
 * @param $sizes
 */
function get_size_options($sizes){
  $size_options= [];
  $size_keys = [];
  $size_values = [];

  foreach($sizes as $size) {
    $size = Node::load($size['target_id']);

    if($size instanceof NodeInterface){
      $size_title = $size->getTitle();
      $size_price = $size->get('field_size_price')->getValue();

      $size_keys[] = $size_price[0]['value'];
      $size_values[] = $size_title;
    }
  }

  $size_options = unique_size_keys($size_keys, $size_values);

  return $size_options;
}

/**
 * @param $keys
 * @param $values
 */
function unique_size_keys($keys, $values) {
  $size_options = [];
  $unique_keys = array_unique($keys);

  for($i = 0; $i < count($keys); $i++){
    $size_options[$keys[$i] . str_repeat(' ', $i)] = $values[$i];
  }

  return $size_options;
}
